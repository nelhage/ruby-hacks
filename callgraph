#!/usr/bin/env ruby
require 'optparse'
require 'parser'
require 'parser/current'
require 'set'
require 'logger'

$log = Logger.new(STDOUT)
$log.level = Logger::INFO

class Processor < Parser::AST::Processor
  # klass: { method: [ (callee, method) ] }
  attr_reader :calls

  def initialize
    @calls   = Hash.new { |h,k| h[k] = {} }
  end

  def call_map
    @calls[@klass]
  end

  def on_def(node)
    @method = node.children[0].to_s
    $log.debug("  def #{@method}")
    call_map[@method] = []
    super
    @method = nil
  end

  def on_class(node)
    orig_klass = @klass
    begin
      @klass = "#{@klass}::#{klass_name(node.children.first)}"
      $log.debug("-> class #{@klass}")
      super
      $log.debug("<- class #{@klass}")
    ensure
      @klass = orig_klass
    end
  end

  alias on_module on_class

  def klass_name(node)
    bits = []
    while node
      raise "wtf #{node}" unless node.type == :const
      bits << node.children[1]
      node = node.children[0]
    end

    return bits.reverse.join("::")
  end

  def on_send(node)
    handle_send(node)
    super
  end

  def handle_send(node)
    return unless @method

    target = node.children[0]
    meth = node.children[1].to_s

    case
    when target.nil?
    when target.type == :ivar
      target = target.children.first.to_s
    else
      return
    end

    call_map[@method] << [target, meth]
  end
end

class DotRenderer
  BLACKLIST = Set.new(%w[log assert
    raise param gating_agent
    testing? __method__ request
    configatron soft_assert])

  def initialize(processor, out, typemap=nil)
    @processor = processor
    @out = out
    @typemap = typemap || {}
  end

  def render_klass(klass, calls)
    calls.each do |src, dsts|
      me = "#{klass}##{src}"
      @out.puts("    #{quote(me)} [style=filled label=#{quote(src)}];")
      dsts.uniq.each do |obj, meth|
        next if BLACKLIST.include?(meth)
        if obj
          $log.debug("looking up #{obj} in #{@typemap.inspect}..")
          next unless dstklass = @typemap[obj]
          dst = "#{dstklass}##{meth}"
        else
          dst = "#{klass}##{meth}"
        end
        @out.puts("    #{quote(me)} -> #{quote(dst)};")
      end
    end
  end

  def render
    @out.puts("digraph G {")
    @out.puts(' page="8.5,11;"')

    @processor.calls.each do |klass, calls|
      if klass
        @out.puts("  subgraph #{quote("cluster_" + klass)} {")
        @out.puts("    label = #{quote(klass)};")
        @out.puts("    color = lightgrey;")
      end
      render_klass(klass, calls)
      @out.puts("  }") if klass
    end

    @out.puts("}")
  end

  def quote(name)
    "\"#{name}\""
  end
end

def parse_args(options)
  optparse = OptionParser.new do |opts|
    opts.banner = <<-EOM
Usage: #{File.basename($0)} [options] file.rb...

Options:
EOM

    opts.on('-d', '--defined', 'Print a list of defined methods') do
      options[:defined] = true
    end

    opts.on('-c', '--called', 'Print a list of called methods') do
      options[:called] = true
    end

    opts.on('-r', '--remote', 'Print a list of called-but-not-defined methods') do
      options[:remote] = true
    end

    opts.on('-t', '--type IVAR=KLASS') do |spec|
      ivar, klass = spec.split('=')
      options[:typemap] ||= {}
      options[:typemap][ivar] = klass
    end

    opts.on('--dot=PATH', 'Write a dot callgraph') do |path|
      options[:dot] = path
    end

    opts.on('-v', 'Verbose') do
      $log.level = Logger::DEBUG
    end
  end

  optparse.parse!

  if ARGV.empty?
    STDERR.puts optparse
    exit 1
  end

  return ARGV
end

def methods_defined(p)
  out = []
  p.calls.each do |klass, calls|
    calls.each do |src, dsts|
      out << "#{klass}##{src}"
    end
  end
  out
end

def methods_called(p)
  out = []
  p.calls.each do |klass, calls|
    calls.each do |src, dsts|
      dsts.each do |target, method|
        next if target
        out << "#{klass}##{method}"
      end
    end
  end
  out.uniq
end


def main
  options = {}
  paths = parse_args(options)
  p = Processor.new

  paths.each do |path|
    parser = Parser::CurrentRuby.new
    buf = Parser::Source::Buffer.new(path).read
    ast = parser.parse(buf)

    p.process(ast)
  end

  if options[:defined]
    methods_defined(p).each do |m|
      puts m
    end
  elsif options[:called]
    methods_called(p).each do |m|
      puts m
    end
  elsif options[:remote]
    (methods_called(p) - methods_defined(p)).each do |m|
      puts m
    end
  end

  if options[:dot]
    f = File.new(options[:dot], 'w')
    DotRenderer.new(p, f, options[:typemap]).render
    f.close
  end
end

if $0 == __FILE__
  main
end
